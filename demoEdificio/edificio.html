<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>

    <style>

    body{
      background-color: #999999;
    }
    #form{
      padding: 20px;
      margin: 5px;
      background-color: white;
    }
    </style>
</head>
<body>

<div id="form">
Ancho Frente <input id="ancho" value="5" size="5"/>
Profundidad <input id="profundidad" value="5" size="5"/>
Altura <input id="altura" value="20" size="5"/> &nbsp;

<button onclick="generar();"> generar</button>
</div>
<div id="container">

</div>

<script type="x-shader/x-vertex" id="vertex-Shader">


    varying vec2 vUv;
    varying vec3 vPosModel;
    varying vec3 vPosWorld;


    uniform float t;


    void main() {

       // position
       vec4 auxPos = vec4(position,1.0);

       float escalaY=min(1.0,t*0.001);
       auxPos.y=auxPos.y*escalaY;
       vPosWorld = (modelMatrix * vec4(auxPos.xyz, 1.0 )).xyz;

       // uv
       vec2 auxUv=uv;
       auxUv.y = auxUv.y*escalaY;



       vUv = auxUv;
       gl_Position = projectionMatrix * modelViewMatrix * auxPos;


    }

</script>





<script type="x-shader/x-fragment" id="fragment-Shader">

    precision highp float;

    uniform sampler2D textura1;
    uniform sampler2D textura2;

    varying vec2 vUv;
    varying vec3 vPosModel;
    varying vec3 vPosWorld;


   uniform float t;


    void main() {

       vec4 color = vec4(1.0,0.0,0.0, 1.0);
       vec2 auxUv = vUv;
       auxUv.x = auxUv.x * 0.67;
       auxUv.x = auxUv.x * 0.3;
       vec4 texColor=texture2D(textura1, vUv);
       vec4 texColor2=texture2D(textura2, auxUv);


       if(vUv.y < 1.0){

         color.x=texColor2.x;
         color.y=texColor2.y;
         color.z=texColor2.z;
       }
       else{
         color.x=texColor.x;
         color.y=texColor.y;
         color.z=texColor.z;
       }

       gl_FragColor = color;

    }

</script>

<script src="js/three.min.js"></script>
<script src="js/jquery-1.9.1.js"></script>
<script src="js/controls/OrbitControls.js"></script>

<script>

    var altura,profundidad,ancho;


    var scene, camera, renderer;

    var tex1=THREE.ImageUtils.loadTexture( "img/ed1_fachada.jpg");
    tex1.wrapS = THREE.RepeatWrapping;
    tex1.wrapT = THREE.RepeatWrapping;

    var tex2=THREE.ImageUtils.loadTexture( "img/ed1_pb.jpg");
    tex2.wrapS = THREE.RepeatWrapping;
    tex2.wrapT = THREE.RepeatWrapping;

    var attributes = {

    };

    var uniforms = {

        t: {
            type: 'f', // a float
            value: 0
        },
        textura1: {
          type: "t",
          value:tex1
        },
        textura2: {
          type: "t",
          value:tex2
        }
    };



    var shaderMaterial = new THREE.ShaderMaterial({
        attributes:     attributes,
        uniforms:       uniforms,
        vertexShader:   $('#vertex-Shader').text(),
        fragmentShader: $('#fragment-Shader').text(),
    });




   function configurarEcena() {

       var RENDER_WIDTH = 1000, RENDER_HEIGHT = 600;

       scene = new THREE.Scene();

       camera = new THREE.PerspectiveCamera(75, RENDER_WIDTH / RENDER_HEIGHT, 0.1, 1000);

       camera.position.set(-5, 5, 10);



       renderer = new THREE.WebGLRenderer({preserveDrawingBuffer: true, autoClear: false});

       renderer.setSize(RENDER_WIDTH, RENDER_HEIGHT);

       renderer.setClearColor(0xffffff, 1);

       var container = document.getElementById('container'); //esto vincula Three.js con el Canvas

       container.appendChild(renderer.domElement);

       controls = new THREE.OrbitControls(camera, container);

       controls.target.x = 0;
       controls.target.y = 0;
       controls.target.z = 0;

       var axis =new THREE.AxisHelper(10);
       scene.add(axis);

   }

   function agregarLuces()
   {
       var ambientLight = new THREE.AmbientLight( 0x404040 );
       scene.add( ambientLight );


       var pointLight = new THREE.PointLight( 0xffffff, 1, 1000 ); // definimos una fuente de Luz puntual de color blanco
       pointLight.position.set( 200, 500, 200 ); // definimos su posicion
       scene.add( pointLight ); // agregamos la luz a la escena

       var pointLight = new THREE.PointLight( 0xffffff, 1, 1000 );
       pointLight.position.set( -500, 500, 0 );
       scene.add( pointLight );

       var pointLight = new THREE.PointLight( 0xffffff, 1, 1000 );
       pointLight.position.set( -200, 500, 200 );
       scene.add( pointLight );


   }
   var modelo;


    var frame=0;
    var cube;

    function render() {
        controls.update();
        requestAnimationFrame(render);

        uniforms.t.value= frame
        renderer.render(scene, camera,false,false);
        frame++;
    };

    configurarEcena();
    agregarLuces();


    function generar(){
        scene.remove(cube);

        altura=$("#altura").val();
        profundidad=$("#profundidad").val();
        ancho=$("#ancho").val();

        console.log("altura="+altura+" ancho="+ancho+" profundidad="+profundidad);

        var combinedGeo = new THREE.Geometry();
        var geometry = new THREE.BoxGeometry( ancho, altura, profundidad );


        var geometry2 = new THREE.BufferGeometry();
        // create a simple square shape. We duplicate the top left and bottom right
        // vertices because each vertex needs to appear once per triangle.
        var vertices = new Float32Array( [
           0,0,0,
           ancho,0,0,
           ancho,altura,0,

           0,0,0,
           ancho,altura,0,
           0,altura,0,

           ancho,0,0,
           ancho,0,-profundidad,
           ancho,altura,-profundidad,

           ancho,0,0,
           ancho,altura,-profundidad,
           ancho,altura,0,

           0,0,0,
           0,altura,-profundidad,
           0,0,-profundidad,

           0,0,0,
           0,altura,0,
           0,altura,-profundidad,


           0,altura,0,
           ancho,altura,0,
           ancho,altura,-profundidad,

           0,altura,0,
           ancho,altura,-profundidad,
           0,altura,-profundidad,
        ] );

        var uvs = new Float32Array( [
           0,0,
           ancho,0,
           ancho,altura,

           0,0,
           ancho,altura,
           0,altura,



           0,0,
           profundidad,0,
           profundidad,altura,

           0,0,
           profundidad,altura,
           0,altura,


           0,0,
           profundidad,altura,
           profundidad,0,

           0,0,
           0,altura,
           profundidad,altura,

           0,0,
           0,0,
           0,0,

           0,0,
           0,0,
           0,0,

        ] );


        // itemSize = 3 because there are 3 values (components) per vertex
        geometry2.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
        geometry2.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );


        var m = new THREE.Matrix4();
        m.makeTranslation(0,altura/2,0);
        combinedGeo.merge(geometry,m);

        var material = new THREE.MeshPhongMaterial( {color: 0x00ff00,side:THREE.DoubleSide} );
        cube = new THREE.Mesh( geometry2, shaderMaterial );
        //cube.position.x=-ancho/2;

       controls.target.x = ancho/2;
       controls.target.y = altura/4;
       controls.target.z = profundidad/2;
       controls.update();

        scene.add( cube );
        frame=0;

    }



    var size = 15;
    var step = 5;

    var gridHelper = new THREE.GridHelper( size, step );
    scene.add( gridHelper );

    render();

</script>




</body>
</html>
